Digital Larry — Yesterday at 16:58
I've located the spot in the SpinCAD code to add additional "registers" so that the simulation works with my 98-register patch.  Easy.  Also it looks like it would not be a ton of work to add more ramp or sine LFOs.

1

1

McNoodles — Yesterday at 19:06
Amazing!  Is it updated in the beta link you shared yesterday?
25 December 2024

Digital Larry — Today at 17:15
no, simulation is still broken in the latest "beta" build if you go over 32 registers.  Thought I'd work it out with Os to see if he wants to head in that direction, and how far, otherwise there is no point in doing it.  Although I did realize that once you have developed a script to turn Spin ASM to C then the industrious individual could adapt that to any target device that has a C compiler. (edited)

1

@Digital Larry
no, simulation is still broken in the latest "beta" build if you go over 32 registers.  Thought I'd work it out with Os to see if he wants to head in that direction, and how far, otherwise there is no point in doing it.  Although I did realize that once you have developed a script to turn Spin ASM to C then the industrious individual could adapt that to any target device that has a C compiler. (edited)

McNoodles — Today at 19:56
There'll always be industrious individuals... and worse, Behringer!

It's probably not right to do further work, moving past the FV-1's capabilities and ostracizing the community SpinCAD was built for.
But... maybe DistingCAD is an entirely new endeavour built around Faust or some other DSP code that's way over my head   - for example, any and all code.

Once all our files are together, I'll probably pop over to all the other FV-1 forums I can find and share what we have gathered and built here.

Which reminds me,  is there a way to open up spn files other than understanding the ASM code?   I've found an oddity in some old spn files in that they seem to run way too fast.  Unfortunately there's no *.spcd  to remedy it with own brain's capabilities .

Digital Larry — Today at 20:03
Well, I don't think that anyone's going to be ostracized as long as the base functionality for real FV-1 users remains intact.  In fact I've often wanted something that was like a "double FV-1" just to get past the limits which are all too easy to hit once you start working in SpinCAD.  The fxCore chip is not instruction compatible with the FV-1 so that was a non-starter for me.  They've developed their own GUI for it finally.  I've used Faust, and think it's pretty swell, but again it's "programming" and not the most intuitive at that.   So I don't actually mind the idea of spending a "little" time, assuming Os was on board with it, to allow Disting to run expanded FV-1 type algos made in SpinCAD.  Whether it's just the same version or a fork remains to be seen.  Doing that does not prevent anyone from doing a Faust interface for it either. (edited)
[20:04]
I don't know of anything that explains spn code, although I can read it pretty well.

Digital Larry — Today at 20:11
The other thing to consider as regards SpinCAD is that it is a GUI on top of a model of the FV-1 written by a different guy.  That's nice in that you get real time simulation out of it.  If you didn't care about that, it would be simple enough to adapt the user interface to generate C code directly, then whoever could just come up with blocks and whatever without having to imagine them as FV-1 code first.  Although if you were going to do that, I might consider leveraging something like the Node-Red UI instead.  I think this is what the Teensy audio tool did.  https://www.pjrc.com/teensy/gui/ (edited)
[20:12]
By "simple" I mean conceptually simple.  Still a lot of work.

@Digital Larry
I don't know of anything that explains spn code, although I can read it pretty well.

McNoodles — Today at 20:12
True, the simplest method may be just to built partial patches that run on Disting AND multiple FV-1,  splitting the load.  Not sure how stable that would be but I'll play around. 

If you have the time, and the willingness, could you say why this 'tape echo' seems to run so fast as to sound more like a Haas channel delay?

Graham_Biswell [odd timing].zip
44.50 KB

Digital Larry — Today at 20:14
there's a bunch of files in here.  which one is it?

@Digital Larry
The other thing to consider as regards SpinCAD is that it is a GUI on top of a model of the FV-1 written by a different guy.  That's nice in that you get real time simulation out of it.  If you didn't care about that, it would be simple enough to adapt the user interface to generate C code directly, then whoever could just come up with blocks and whatever without having to imagine them as FV-1 code first.  Although if you were going to do that, I might consider leveraging something like the Node-Red UI instead.  I think this is what the Teensy audio tool did.  https://www.pjrc.com/teensy/gui/ (edited)

McNoodles — Today at 20:18
all of them.   they're supposed to be delays but i load them in VCV's FV-1 simulator  and they sound haas-like as opposed tape delays..
VCV Library
EH-modules FV-1.emu
Spin Semi FV-1 DSP chip emulator


Digital Larry — Today at 20:19
Don't suppose you have a real FV-1 to test them on?

McNoodles — Today at 20:20
unfortunately not.  I was about to until Os ported the code
[20:21]
i'll test on Disting, see if it plays back properly there.   I just thought something obvious might pop out

Digital Larry — Today at 20:23
Yeah cough FV-1 code is anything but obvious.  Maybe I'll check one of these out on my AudioFab pedal.  Kinda depends, perhaps VCV FV-1 thingey has some bug or limitation, I have no idea, and not interested in debugging it.

McNoodles — Today at 20:26
Oh well, it's no biggie.  I was just trying to get the last of our working spn files labelled up and converted to .3pot.   Once I'm home I'll load them up in the Disting..  The VCV emu, as you say, could be one of a myriad factors.

Digital Larry — Today at 20:26
Does VCV FV-1 emulator eat FV-1 ASM or hex? (edited)

@Digital Larry
Does VCV FV-1 emulator eat FV-1 ASM or hex? (edited)

McNoodles — Today at 20:27
just .spn or spn bank.

Digital Larry — Today at 20:28
okay so they are interpreting the SPN code somehow.
[20:28]
Here's a section where the delay pointer is being calculated.
[20:28]
; Tap 0
or    tap0 * 256            ; Load left base address
rdax    t0_offset, 1            ; add pointer offset
wrax    addr_ptr, 0            ; Write it to the address pointer register
rmpa    1                ; Read from memory
wrax    t0_data, 0            ; Write data from delay output to register
[20:29]
if it does not do that "tap0 * 256" correctly then your delays will be 1/256 as long as they should be

McNoodles — Today at 20:30
that actually seems about right.
[20:31]
That's some quick deduction.   hopefully it's a bug in vcv that we don't have in the disting

Digital Larry — Today at 20:31
one way to check this would be to find those points in the code and then calculate "tap0 * 256" yourself and just substitute it.

1
[20:32]
For example
[20:32]
mem    tap0        delay_len
mem    tap1        delay_len
mem    tap2        delay_len
[20:32]
equ    delay_len    10800
[20:33]
tap0 is the base of the memory allocation and as it's the first mem statement, tap0 = 0, tap1 = 10800, tap2 = 21600.  Try those values and see what happens (edited)

McNoodles — Today at 20:34
you're speaing mandarin to a british cat, but i'll try!

Digital Larry — Today at 20:34
blimey
[20:34]
LOL

1
[20:34]
; Tap 0
or    tap0 * 256            ; Load left base address
[20:34]
tap0 = 0.
[20:35]
replace that line with
[20:35]
or 0
[20:35]
or    tap1 * 256
[20:35]
replace that line with
[20:35]
or 2764800
[20:36]
or    tap2 * 256
[20:36]
replace with
[20:36]
or 5529600
[20:36]
this was in the tripple_echo_parallel.spn

McNoodles — Today at 20:39
ooh, close! I went for tripple_echo_cascaded.

I'll take a look at parallel

Digital Larry — Today at 20:39
might be the same thing
[20:42]
there are also these statements in several places
[20:42]
or    delay_len*256 (edited)
[20:43]
replace each of those with
[20:43]
or 2764800
[20:43]
I'll check in later

Digital Larry — Today at 20:46
doing this means that you can't just change "delay_len" in one place and have it work properly.  But if these changes I suggested make it work on VCV then that suggests some issue with their code parsing.  Seems like it would have come up sooner though as  lot of FV-1 code works this way to address into the delay RAM
[20:47]
should have no effect working as-is on a real FV-1 or anything which emulates it properly

McNoodles — Today at 20:51
it's weird that I almost understand what I'm doing..  and it will be interesting to see if Os' code runs this without error.   Thanks AGAIN for the knowledge bomb!!
[20:58]
it works as it should. I'M a genius.

McNoodles — Today at 20:59


Digital Larry — Today at 21:20
really?  cool.

McNoodles — Today at 21:20
So I take it 10800 is an arbitrary unit of time for the delay length.

but 256*that number gives us the values we set.

Digital Larry — Today at 21:21
10800 roughly divides the available RAM into 3 different lines

McNoodles — Today at 21:21
oh, it's ram

Digital Larry — Today at 21:21
yep
[21:22]
these instructions are calculating RAM addresses

McNoodles — Today at 21:22
so we're using the 3rds of ram upto 256 times with an opened pot?

Digital Larry — Today at 21:23
the 256 factor is simply an artifact of how the FV-1 likes to see memory addresses

McNoodles — Today at 21:23
or in one case, 512 times

Digital Larry — Today at 21:24
if you want to read/write into location X you have to give the memory pointer 256 * X

McNoodles — Today at 21:24
oooooh
[21:28]
256 is a number of bits /bytes. segments of ram.     like the allocation units on a disk always read/write in a set cluster size
[21:29]
i'll get there... one day. 
school's harder in my 40s but i'm far more engaged

Digital Larry — Today at 21:30
ehh... there are really only 32768 RAM addresses.  The 256 factor (I think) is simply so that, the address, when thought of as 0 to 1, scales along with everything else in the FV-1 world.  FV-1 word length is 24.  32768 = 2^15
[21:30]
if you use a POT control to index into RAM, it is 11 bits, but it is left-justified, so appears to go from 0 to 1.  Connect a POT to your RAM pointer and you can scan from beginning to end easily.
[21:31]
this is all FV-1 specific and probably doesn't map to other realms.

1

McNoodles — Today at 21:47
i'm reluctant to ask more questions - i have many.
but...
if 

t0_delay, 0
or 2764800 (256)

t1_delay, 0
or 2764800 (256)

t2_delay, 0 (*512)
or 5529600

t0 & t1 are pulling the same data. Probably a mono source ?

But 5529600 ?

Digital Larry — Today at 21:48
#1 first one should be 0

McNoodles — Today at 21:49
AHHHHH!!!   3 taps from 3 memory divisions...

Digital Larry — Today at 21:49
sorry, hang on a moment

McNoodles — Today at 21:49
I should read the spin docs

Digital Larry — Today at 21:49
This calculates the base address for each section of the memory buffer.
[21:49]
; Tap 0
or    tap0 * 256            ; Load left base address
[21:50]
This set of 3 instructions assigns memory addresses to tap0, tap1, tap2
[21:50]
mem    tap0        delay_len
mem    tap1        delay_len
mem    tap2        delay_len
[21:50]
since tap0 is the first mem statement, it is at 0
[21:51]
tap1 is the start of the next buffer.  delay_len up from 0.
[21:51]
tap2 is the beginning of the next buffer delay_len up from tap 1

McNoodles — Today at 21:51
got it.

Digital Larry — Today at 21:52
The pot processing code does the following:
[21:52]
; set pointer for each tap based on pot value
rdax    t0_pot, 1
sof    0.99, 0.01
wrax    t0_delay, 0
or    delay_len*256            ; Put delay length into ACC aligned to ACC[22:8]
mulx    t0_delay            ; Multiply by delay amount
rdfx    t0_offset, smooth
wrax    t0_offset, 0
[21:52]
first two instructions make sure that the minimum is 0.01 rather than 0
[21:53]
which is written to t0_delay
[21:53]
wrax    t0_delay, 0
[21:54]
the rest of that scales the pot value against the delay length and filters it (smoothing) which will usu give pitch bending when you adjust.  Without smoothing RAM address jumps will result in glitches
[21:56]
t0_offset and t2_offset and t2_offset are then filtered fractional offsets into the delay RAM. (edited)
[21:57]
This section a) gets the base address b) adds the offset c) writes result into ram pointer reg (addr_ptr) d) reads from that pointer (RMPA) and e) writes ACC to register t0_data (edited)
[21:57]
or    tap0 * 256            ; Load left base address
rdax    t0_offset, 1            ; add pointer offset
wrax    addr_ptr, 0            ; Write it to the address pointer register
rmpa    1                ; Read from memory
wrax    t0_data, 0            ; Write data from delay output to register
[21:58]
there will be a quiz next week

1

McNoodles — Today at 21:59
I'll read up, I don't want to take up your entire life with nonsensical questions..  It's sinking in but it's currently  wearing 256* inflatable life jackets that will hopefully deflate as I get further in

1

Digital Larry — Today at 22:00
it's not so much nonsensical as not super applicable to anything else
[22:00]
I spent about a year figuring it out and I studied DSP at university

McNoodles — Today at 22:01
It's my questioning that will be nonsensical.  Thanks AGAIN!  This will be a super useful reference.

Digital Larry — Today at 22:01
it's moderately amusing to talk about this with someone who is interested, so don't worry.  If I don't feel like answering I'll let you know (edited)

1

McNoodles — Today at 22:04
uh oh....    Instaregret

Digital Larry — Today at 22:07
???